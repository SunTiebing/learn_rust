## 题目1

1. 使用枚举包裹三个不同的类型，并放入一个Vec中，对Vec进行遍历，调用三种不同类型的各自的方法

   [code](vec_enum.rs)

1. 定义三个不同的类型，使用Trait Object，将其放入一个Vec中，对Vec进行遍历，调用三种不同类型的各自的方法

   [code](vec_trait.rs)

### 两种实现的区别

1. **枚举包裹的方式**：这种方式更简单直接，因为你只需要定义一个枚举类型来包裹所有可能的类型，然后在遍历集合时使用`match`语句来检查每个项的类型并调用相应的方法。这种方式不需要使用动态分配（如`Box`），因此，它在性能上可能会优于trait对象。然而，它的缺点是你需要为所有可能的类型定义一个枚举成员，并且在添加新类型时需要修改枚举和所有的`match`语句。

2. **Trait对象的方式**：这种方式更灵活，因为你可以为任何实现了指定trait的类型创建一个trait对象。这意味着你可以在不修改集合类型的情况下添加新的类型。但是，这种方式需要动态分配和动态派发，因此可能在性能上稍逊于枚举包裹的方式。另外，它还需要你定义一个trait，并为所有的类型实现这个trait。这可能会比定义一个枚举类型更复杂。


## 题目2

[code](add_operator.rs)